continue
pp path_cache.paths
continue
pp path_cache.paths
continue
pp path_cache.paths
continue
pp path_cache.paths
exit
continue
contin
b.marker
a.marker
continue
exit
continue
exit
rect_graph.nodes.map(&:marker)
rect_graph.nodes.keys
continue
exit
rect_graph.print
pp path_cache.paths; nil;
pp path_cache.paths;
pp path_cache.paths
rect_graph.nodes[6].edges[4].adjacent_cells
rect_graph.nodes[6].edges[4]
rect_graph.nodes[6].edges.first.first
rect_graph.nodes[6].edges.first.class.name
rect_graph.nodes[6].edges.first
rect_graph.nodes[6].edges.keys
rect_graph.nodes[6].edges
rect_graph.nodes[6]path_cache.paths
path_cache[4][0]
path_cache[6][0]
path_cache[5][6]
path_cache[6][0]
path_cache[6][5]
path_cache[6][4]
continue
exit
path_cache.paths[0][1]
path_cache.paths[0][1].object_id
z1path.object_id
path_cache.paths[0][1] = z1path
z1path = Array.new
path_cache.paths[0][1].object_id
pp path_cache.paths[0][1]
pp path_cache.paths[0]
pp path_cache.paths
path_cache.paths[0][1] = []
paths[0][1] = []
path_cache.paths[0]
path_cache.path[0]
path_cache.set_edge(n0, n1)
path_cache.set_edge(node[0], node[1])
rect_graph.print
puts path_cache.paths
pp path_cache.paths
rect_graph.path_cache.expand!
rect_graph.nodes.cache_paths.expand!
rect_graph.nodes.first.marker
rect_graph.nodes.first.edges.values.map { |n| n.to.marker } 
rect_graph.nodes.first.edges.values.map(&:to)
path_cache.paths[1][0]
path_cache.paths[1]
path_cache.paths[0]
path_cache.paths.keys
path_cache.paths
